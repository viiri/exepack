use std::convert::TryFrom;
use std::env;
use std::fs;
use std::io::{self, Write};
use std::iter;
use std::path;

use exe;

pub fn save_exe<P: AsRef<path::Path>>(path: P, exe: &exe::Exe) -> Result<(), Box<dyn std::error::Error>> {
    let f = fs::File::create(path)?;
    let mut w = io::BufWriter::new(f);
    exe.write(&mut w)?;
    w.flush()?;
    Ok(())
}

// call save_exe if the environment variable EXEPACK_TEST_SAVE_EXE is set.
pub fn maybe_save_exe<P: AsRef<path::Path>>(path: P, exe: &exe::Exe) -> Result<(), Box<dyn std::error::Error>> {
    if let Some(_) = env::var_os("EXEPACK_TEST_SAVE_EXE") {
        save_exe(path, exe)?;
    }
    Ok(())
}

// A short program to appear at the beginning of test programs to make them
// actually runnable in DOS. The bytes correspond to the assembly program
// ```
//         mov dx, (ok+0x100)      ; ds points to PSP, 0x100 bytes before cs
//         mov ah, 0x09            ; write string to standard output
//         int 0x21
//         mov ax, 0x4c00          ; terminate with status 0
//         int 0x21
// ok:
//         db      "ok$"
// ```
const PREFIX: [u8; 15] = *b"\xba\x0c\x01\xb4\x09\xcd\x21\xb8\x00\x4c\xcd\x21ok$";

// Generates a stream of bytes that is easily compressible.
fn compressible_iter() -> impl iter::Iterator<Item = u8> + Clone {
    iter::repeat(b'X')
}

// Generates a stream of bytes with no repetition, so its size cannot be smaller
// after compression.
fn incompressible_iter() -> impl iter::Iterator<Item = u8> + Clone {
    b"_-".iter().cloned().cycle()
}

// Generates a stream of bytes that is somewhat compressible, but not as much as
// those generated by compressible_body.
fn semicompressible_iter() -> impl iter::Iterator<Item = u8> + Clone {
    compressible_iter().take(16).chain(incompressible_iter().take(16)).cycle()
}

pub fn compressible_text(len: usize) -> Vec<u8> {
    PREFIX.iter().cloned().chain(compressible_iter()).take(len).collect()
}

pub fn incompressible_text(len: usize) -> Vec<u8> {
    PREFIX.iter().cloned().chain(incompressible_iter()).take(len).collect()
}

pub fn semicompressible_text(len: usize) -> Vec<u8> {
    PREFIX.iter().cloned().chain(semicompressible_iter()).take(len).collect()
}

/// Panics if two `Exe`s are not equivalent.
///
/// We don't ask for perfect identity. The packing/unpacking roundtrip may
/// change the size of the header, and may add padding to the end of the body.
/// The location of the relocation table may change.
pub fn assert_exes_equivalent(a: &exe::Exe, b: &exe::Exe) {
    // Let a be the one with the shorter body.
    let (a, b) = if a.body.len() <= b.body.len() {
        (a, b)
    } else {
        (b, a)
    };

    // The second e_minalloc must be at least as large as the first, but may be
    // larger.
    assert!(
        a.body.len() + usize::from(a.e_minalloc)*16 <= b.body.len() + usize::from(b.e_minalloc)*16,
        "{}+{}*16={} {}+{}*16={}",
        a.body.len(), a.e_minalloc, a.body.len() + usize::from(a.e_minalloc)*16,
        b.body.len(), b.e_minalloc, b.body.len() + usize::from(b.e_minalloc)*16,
    );
    assert_eq!(a.e_maxalloc, b.e_maxalloc);
    assert_eq!(a.e_ss, b.e_ss);
    assert_eq!(a.e_sp, b.e_sp);
    assert_eq!(a.e_ip, b.e_ip);
    assert_eq!(a.e_cs, b.e_cs);
    assert_eq!(a.e_ovno, b.e_ovno);

    let diff = (isize::try_from(b.body.len()).unwrap())
        .checked_sub(isize::try_from(a.body.len()).unwrap()).unwrap();
    // should not add more than 15 bytes of padding
    assert!(0 <= diff && diff < 16, "{} {}", a.body.len(), b.body.len());
    let (b_body, b_padding) = b.body.split_at(a.body.len());
    // body up to padding must be identical
    assert_eq!(a.body, b_body);
    // padding must be zeroed
    for c in b_padding {
        assert_eq!(*c, 0x00, "{:?}", b_padding);
    }

    // relocations must be identical up to order
    let mut a_relocs = a.relocs.clone();
    a_relocs.sort();
    let mut b_relocs = a.relocs.clone();
    b_relocs.sort();
    assert_eq!(a_relocs, b_relocs);
}
